@Entity = POJO class
@Table(name = "employee") = current POJO class which corresponds to a table with the name 'employee'
@Cacheable = the current entity is able to use the second level cache
@Id = identify the field as id
@GeneratedValue(strategy = GenerationType.IDENTITY) = the current field is automatically generated by the database (in the same table)
@Column(name = "id", nullable = false, updatable = false) = the column which the current field correspond to
@NamedQuery(query = "Select e from Employee e where e.id = :id", name = "Employee.findById") = a query which can be invoked for the entity that belongs to using Employee.findById identifier
@CreationTimestamp = timestamp regarding the creation of the record in the database
@UpdateTimestamp = timestamp regarding the update of the record in the database
@Inheritance(strategy = InheritanceType.SINGLE_TABLE) = the current entity may be inherited by other classes using SINGLE_TABLE strategy which will insert all the records in a single table
@DiscriminatorColumn(name = "type") = the column which will act as an identifier (in order to keep track which record belongs to which entity)
@DiscriminatorValue(value = "F") = the value to be inserted in the @DiscriminatorColumn in order to keep track of what entity current record belongs to
@OneToOne = maps one-to-one relationship with the entity the field corresponds to
@OneToMany = maps one-to-many relationship with the entity the field corresponds to
@ManyToMany = maps many-to-many relationship with the entity the field corresponds to
@JoinTable(name = "employee_projects", joinColumns = {@JoinColumn(name = "project_id")}, inverseJoinColumns = {@JoinColumn(name = "employee_id")}) = creates a join table named 'employee_projects' which uses 'project_id' column of the current entity and the 'employee_id' of the other entity in order to map them within the table
@find() = returns the object fetching it firstly from the cache then from the database
@getReference() = returns the reference of an object that might not exist (a proxy object); loads the data from cache/database only when you access other properties of the object
@manager.find(Entity.class, id) = find entity in database with id = id
@manager.persist(entity) = add entity to database
@manager.remove(entity) = remove entity from database
@manager.merge(entity) = update entity in database
@MappedSuperclass = will not be persisted in the database; acts like a simple parent class for the classes that extend it
@Embeddable = a class which can be a field of other's
@Embedded = the field is an embeddable type
@UniqueConstraint = only one kind of a value/pair of values can be injected into the database (i.e.: if you already have an EMPLOYEE_NAME = MIHAI in the database, and you try to insert a new employee with the same name (MIHAI), it will throw an error - same with combinations of columns)
@MapKey(name = [COLUMN-NAME]) = when using a map, we need to associate at least two entities. So, for example if we have a OneToMany <-> ManyToOne relationship, we could define a map inside the OneToMany entity to have multiple instances of ManyToOne entity, maping the id of each entity, so they could be identified in the map where Hibernate is going to inject them 
