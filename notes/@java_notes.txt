OOP PRINCIPLES
1. Encapsulation
	a. each object keeps its state private inside a class
2. Abstraction
	a. extension of encapsulation
	b. each object should only expose a high-level mechanism for using it
	c. hides implementation details
3. Inheritance
	a. reusability
4. Polymorphism
	a. use the child classes as the parent, without mixing types

SOLID
S = single responsibility
O = open-closed (open for extension, closed for modification)
L = Liskov substitution (simple replaceability of objects)
I = interface segregation (no client should be forced to depend on methods it does not use)
D = dependency inversion (high level modules do not depend on low level modules / abstractions should not depend on details, but viceversa)
---------------------------------

ACID
A = Atomicity
C = Consistency
I = Isolation
D = Durability
---------------------------------

JAVA - ACCESS CONTROL MODIFIERS
1. default - scope: same package
2. public - scope: everywhere
3. protected - scope: within the package & subclasses
4. private - scope: within the class
-------------------------------------------

JAVA - NON-ACCESS MODIFIERS
1. Final
2. Static
3. Transient
4. Synchronized
5. Volatile

FINAL
 - used with variable, method or class
 - final method cannot be overriden, but can be used in subclass
 - final class cannot be inherited (i.e.: String)

 STATIC:
 - can be accessed without instance of a class (i.e.: Employee.COMPANY_NAME)
 - allocated memory only once (saves memory)
 - all instances of a class will use the same reference of a static variable

 TRANSIENT
 - not serializable

 SYNCHRONIZED
 - access permited only by one thread at a time

 VOLATILE
 - tells the compiler that a variable can be changed unexpectedly
 - only used with variables
 --------------------------------

 INSTANCEOF
 - used to determine the type of an object
 - if a extends b => b instance of a == true
 ------------------------------------

 STRING
 - immutable - state cannot be changed
 - everytime you create a new String (either by "" or using new operator) the JVM checks the String Pool first -> 
 	a. if the String exists in the String Pool, it returns the reference to it
 	b. if the String does not exists in the String Pool, it creates a new object in memory and places it in the pool as well for further use
 - COMPARISONS:
 	a. equals() = compares content
 	b. compareTo() = compares content
 	c. == - compares references
------------------------------------------------------------

STRINGBUFFER                                                | 
- mutable - state can be changed                            |  
- used when we perform a lot of modifications to our string |  
- thread-safe                                               |     
- has reverse() function                                    |  => StringBuffer is slower than StringBuilder due to synchronization
                                                            |  
STRINGBUILDER                                               |  
- mutable - state can be changed                            |
- used when we perform a lot of modifications to our string |
- NOT THREAD-SAFE (because of its methods)                  |
-------------------------------------------------------------

EXCEPTIONS
1. Checked - checked at compile time (i.e.: FileNotFoundException)
2. Unchecked - checked at runtime (i.e.: NullPointerException, ArrayIndexOutOfBound)
3. Inner tries are allowed. They make use of its own catch() clauses as well as the outer catch() clauses, should the need arise
-------------------------------------------------------------

THREADS
1. Lifecycle:
	a. New
	b. Runnable
		i. by calling start() when in New state
	c. Running
	4. Waiting 
		i. still alive
		ii. waiting for another thread to perform a task
	5. Terminated
		i. when it completes its task
2. Priorities:
	a. MIN-PRIORITY == 1
	b. MAX-PRIORITY == 10
	c. NORM-PRIORITY == 5 (assigned by default to every thread)
3. How to create a thread:
	a. extending Thread class
	b. implementing Runnable interface
4. start() 
	a. starts a thread (which firstly provides a new stack to the thread, and secondly calls run() method)
	b. if you call run() method directly, there will be no stack provided to the thread, therefore the thread will run in the current cstack, which belongs to the main thread
5. join()
	a. waits until thread terminates
6. synchronized keyword - resource (method, field) can be accessed only by one thread at a time
7. synchronized block - used when you want to synchronize access to an object / part of a method
8. deadlock - no thread can complete its execution because resources are locked (i.e.: T1 holds a but needs b; T2 holds b but needs a)
--------------------------------------------------------

ABSTRACT CLASS VS. INTERFACE
1. an abstract class lets its methods have bodies, whereas interfaces do not
2. an abstract class is a real class, whereas an interface is an empty template
3. an abstract class allows access modifiers (because it is a real class), whereas interfaces do not (everything is declared as public by default)
4. an abstract class could be inherited by a class once at a time, whereas multiple interfaces could be implemented by a class
--------------------------------------------------------

WRAPPERS:
1. Types
	a. Character
	b. Boolean
	c. Numeric:
		+ Byte
		+ Short
		+ Integer
		+ Long
		+ Float
		+ Double
2. Autoboxing = primitive encapsulated into its Wrapper
3. Auto-unboxing = primitive extracted from its Wrapper
4. d = Integer i + Double d (phases)
	a. Auto-unboxing of i into int
	b. Auto-unboxing of d into double
	c. Perform the addition
	d. Autoboxing of d into Double
---------------------------------------------------------

SERIALIZATION / DESERIALIZATION
1. serialization - convert an object into a sequence of bytes
2. deserialization - convert a sequence of bytes into an object
3. ObjectOutputStream: 
	a. writeObject()
	b. readObject()
4. Static fields do no get serialized (they belong to the class, not the object)

---------------------------------------------------------

GENERICS
1. available with classes, interfaces and methods
2. provides type-safety
3. work only with objects (not primitives)
---------------------------------------------------------

COLLECTIONS:
1. Collection (I)
	a. Set (I)
		+ Hashset (C)
		+ LinkedHashSet (C)
		+ SortedSet (I)
			+ TreeSet (C)
	b. List (I)
		+ LinkedList  (C)
		+ ArrayList (C)
		+ Vector (C)
	c. Queue (I)
		+ LinkedList (C)
		+ PriorityQueue (C)

2. Map (I)
	a. HashTable (C)
	b. LinkedHashMap (C)
	c. HashMap (C)
	d. SortedMap (I)
		+ TreeMap (C)

3. List
	a. random access and insertion, based on position
	b. allows duplicates
	c. additional methods:
		+ get(index)
		+ set(index, obj)
		+ indexOf(obj)
		+ subList(start, end)

4. Set
	a. does not allow duplicates
	b. subinterface SortedSet arranges elements in natural order

5. Queue
	a. follows FIFO principle
	b. additional methods:
		+ poll()
			- removes head element
			- returns null if queue is empty
		+ remove()
			- removes head element
			- returns NoSuchElementException if queue is empty
		+ peek()
			- returns head element (without removing)
			- returns null if queue is empty
		+ element()
			- return head element (without removing)
			- returns NoSuchElementException if queue is empty
		+ offer()
			- adds object to the queue

6. ArrayList
	a. dynamic size
	b. slow manipulation due to the need of a lot of shifting if removing an element
	c. random access
	d. not synchronized
	e. maintains insertion order

7. LinkedList (List, Queue, Stack)
	a. dynamic in nature - allocates memory when required
	b. fast manipulation due to the no need of shifting
	c. sequential access
	d. not synchronized
	e. difficult reverse traversing

8. ArrayList vs. LinkedList
	a. ArrayList allows random access, LinkedList allows sequential access
	b. ArrayList access and manipulation of elements is faster (random access), LinkedList slower (sequential access)
	c. ArrayList can only be a List, LinkedList can be a List, Queue or Stack
	d. both are not synchronized

9. HashSet
	a. uses hash table for storage
	b. no order

10. LinkedHashSet
	a. maintains a LinkedList of entries
	b. maintains insertion order

11. TreeSet
	a. ascending order (if no comparator)
	b. fast access of elements

12. PriorityQueue
	a. dynamic size
	b. ascending order (if no comparator)
	c. does not follow FIFO principle
---------------------------------------------------------

ITERATOR
1. Iterator
2. ListIterator
3. for-each loop
	a. for (String str : arrayOfStrings)
	b. arrayOfStrings.forEach(str -> ... )
---------------------------------------------------------

MAP
1. stores data in key and value association
2. keys must be unique, values can be duplicates

3. HashMap
	a. uses hashtable to store the map
	b. no order

4. TreeMap
	a. stores data in a tree structure
	b. provides efficient means of storing key/value pair in efficient order
	c. sorted order
	d. allows rapid retrieval

5. LinkedHashMap
	a. maintains insertion order (in a LinkedList)
	b. adds one method: removeEldestEntry() which can be overriden to remove the oldest element in the map